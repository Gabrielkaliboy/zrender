<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>实现坐标系联动</title>
    <script src="https://cdn.bootcss.com/jquery/1.10.2/jquery.js"></script>
    <style>
        #main{
            margin:200px auto;
            border:2px solid #000;
        }
    </style>
    <script type="text/javascript" src="../doc/asset/js/esl/esl.js"></script>
</head>
<body>
    <div id="main" style="width:500px;height:500px;"></div>
    <script type="text/javascript">
    //6500k
    var arrData={
        "g11":86,
        "g12":-40,
        "g22":45,
        "x0":0.313,
        "y0":0.337,
        "r1":5,
        "r2":6//必须是大的！
    };
    //2700k
    var arrData1={
        "g11":40,
        "g12":-19.5,
        "g22":28,
        "x0":0.459,
        "y0":0.412,
        "r1":4,
        "r2":6
    };
    //3000k
    var arrData2={
        "g11":39,
        "g12":-19.5,
        "g22":27.5,
        "x0":0.44,
        "y0":0.403,
        "r1":5,
        "r2":6
    };
    function myEllipse(){

    };
    myEllipse.prototype={
        drawMain:function(divid,arrData){
            this.Mainclass(divid,arrData);
        },
        Setting:{
            //初始值
            frameX:0,//起点x
            frameY:0,//起点y
            frameX_end:200,//终点x
            frameY_end:200,//终点y
            contain_width:200,//容器宽
            contain_height:200,//容器高
            arrData:arrData,//传入的数据
            xMin:null,//最大最小值
            xMax:null,
            yMax:null,
            yMin:null, 
            sectionX:null,//xy轴最大最小值之差
            sectionY:null,
            sectionXStep:null,//xy轴按照8份分割，每份的步数值
            sectionYStep:null,
            kX:null,//每个格多少像素
            kY:null,
            mX:null,//1比例的输入值对应的网页中的像素
            mY:null
        },
        Mainclass:function(divid,arrData){
            //获取容器的高度
            this.Setting.contain_height = $("#" + divid).height();  
            //获取容器的高度
            this.Setting.contain_width= $("#" + divid).width();
            //根据获取的容器宽高来设置真实坐标系中每格代表多少像素
            this.Setting.kX=this.Setting.contain_width/10;
            this.Setting.kY=this.Setting.contain_height/10;
            this.Setting.arrData=arrData;
            //初始化设置一下最大最小以及步长
            myEllipse.prototype.XYAxis();
            //顺序不能变，必须先初始XYAxis函数，否则sectionXStep是null
            this.Setting.mX=this.Setting.kX/this.Setting.sectionXStep;
            this.Setting.mY=this.Setting.kY/this.Setting.sectionYStep;
            require.config({
                packages: [
                    {
                        name: 'zrender',
                        location: '../src',
                        main: 'zrender'
                    }
                ]
            });
            require(
                [
                    "zrender",
                    'zrender/shape/Line',
                    'zrender/shape/Text',
                ], 
                function(zrender, LineShape, TextShape){

                    // 初始化zrender
                    var zr = zrender.init(document.getElementById(divid));
                    myEllipse.prototype.DrawTrend=function(arrData){

                        //画与y轴平行
                        var sectionXStep=(Math.ceil((myEllipse.prototype.Setting.sectionXStep.toFixed(5))*1000))/1000;
                        //我修改了sectionXStep,我在把它设置回全局,目的是为了后面画圆的时候知道一个格对应多少像素
                        myEllipse.prototype.Setting.sectionXStep=sectionXStep;
                        var lineXLabelName=myEllipse.prototype.Setting.xMin-sectionXStep;
                        //均分10格，每格多少px
                        var kX=myEllipse.prototype.Setting.kX;
                        for(var i=0;i<myEllipse.prototype.Setting.contain_width;i++){
                            //每个格sectionXStep对应kX像素!!
                            if(i%kX==0){
                                var stepX=i;
                                //画与y轴平行的辅助线
                                var lineX = new LineShape({
                                    style:{
                                        xStart :stepX ,
                                        yStart : 0,
                                        xEnd : stepX,
                                        yEnd : myEllipse.prototype.Setting.contain_height,
                                        strokeColor : '#BFBFBF',   // == color
                                        lineWidth : 2,
                                        lineCap : 'butt',
                                        lineType : 'dotted',
                                        text:stepX,
                                        textPosition:'end'
                                    },
                                });
                                zr.addShape(lineX);


                                //画与y轴平行的辅助线的脚标
                                lineXLabelName=lineXLabelName+sectionXStep;
                                var lineXName=lineXLabelName.toFixed(3);
                                var lineXLabel = new TextShape({
                                    style:{
                                        x : stepX+33,//+15让他往右一点,加的越多越往右
                                        y : myEllipse.prototype.Setting.contain_height-8,//-8让他往上移点
                                        brushType : 'both',
                                        color : '#000',
                                        strokeColor : '#000',
                                        lineWidth : 1,
                                        text : lineXName,
                                        textPosition:"top",
                                        textAlign:"center"
                                    },
                                });
                                zr.addShape(lineXLabel);
                            };
                        };

                        //画与x轴平行
                        //由于sectionYStep的值是小数点后好几位，导致轴系坐标不等宽，我们处理一下，这个值可以偏大
                        //但是不可以偏小，否则会导致溢出,例如sectionYStep=0.00625,我们把它变为0.007
                        var sectionYStep=(Math.ceil((myEllipse.prototype.Setting.sectionYStep.toFixed(5))*1000))/1000;
                        //设置回去
                        myEllipse.prototype.Setting.sectionYStep=sectionYStep;
                        var lineYLabelName=myEllipse.prototype.Setting.yMin-sectionYStep;
                        //均分10格，每格多少px
                        var kY=myEllipse.prototype.Setting.kY;
                        for(var m=0;m<myEllipse.prototype.Setting.contain_height;m++){
                            if(m%kY == 0){
                                var stepY=m;
                                var lineY = new LineShape({
                                    style:{
                                        xStart :0 ,
                                        yStart : myEllipse.prototype.Setting.contain_height-stepY,
                                        xEnd : myEllipse.prototype.Setting.contain_width,
                                        yEnd : myEllipse.prototype.Setting.contain_height-stepY,
                                        strokeColor : '#BFBFBF',   // == color
                                        lineWidth : 2,
                                        lineCap : 'butt',
                                        lineType : 'dotted',
                                        text:'',
                                        textPosition:'end'
                                    },
                                });
                                zr.addShape(lineY);

                                //画与x轴平行的辅助线的脚标
                                lineYLabelName=lineYLabelName+sectionYStep;
                                var lineYName=lineYLabelName.toFixed(3);
                                var lineYLabel = new TextShape({
                                    style:{
                                        x : 0+20,//+15让他往右一点
                                        y : myEllipse.prototype.Setting.contain_height-stepY-43,//整体向上移动40px
                                        brushType : 'both',
                                        color : '#000',
                                        strokeColor : '#000',
                                        lineWidth : 1,
                                        text : lineYName,
                                        textPosition:"top",
                                        textAlign:"center"
                                    },
                                });
                                zr.addShape(lineYLabel);
                            };
                        };

                        //画椭圆
                        for(var angle=0;angle<360;angle++){
                            //获取传入的数据
                            var arrDataModel=myEllipse.prototype.Setting.arrData;
                            var result=myEllipse.prototype.XYTransition(arrDataModel,angle);

                            //小圆
                            var EllipseDotLittle = new LineShape({
                                style:{
                                    xStart :result[0],
                                    yStart :result[1],
                                    xEnd : result[0]+1,
                                    yEnd : result[1]+1,
                                    strokeColor : '#000',   // == color
                                    lineWidth : 1,
                                    lineCap : 'butt',
                                    lineType : 'solid',
                                    text:'',
                                    textPosition:'end'
                                },
                            });
                            zr.addShape(EllipseDotLittle);

                            //大圆
                            var EllipseDotBig = new LineShape({
                                style:{
                                    xStart :result[2],
                                    yStart :result[3],
                                    xEnd : result[2]+1,
                                    yEnd : result[3]+1,
                                    brushType:"stroke",
                                    strokeColor : '#f00',   // == color
                                    lineWidth : 1,
                                    lineCap : 'butt',
                                    lineType : 'solid',
                                    text:'',
                                    textPosition:'end'
                                },
                            });
                            zr.addShape(EllipseDotBig);

                        };




                        //画中心点
                        var EllipseX0Y0 = new LineShape({
                            style:{
                                xStart :result[4] ,
                                yStart : result[5],
                                xEnd : result[4]+1,
                                yEnd : result[5]+1,
                                strokeColor : '#000',   // == color
                                lineWidth :2 ,
                                lineCap : 'butt',
                                lineType : 'solid',
                                text:'',
                                textPosition:'end'
                            },
                        });
                        zr.addShape(EllipseX0Y0);


                        zr.render();
                    };
                    myEllipse.prototype.DrawTrend();

                })
        },
        EllipseXY:function(arrData,angle){
            //核心算法,计算正常坐标系中的椭圆上的xy值
            var g11=arrData.g11,
                g12=arrData.g12,
                g22=arrData.g22,
                x0=arrData.x0,
                y0=arrData.y0,
                r1=arrData.r1,
                r2=arrData.r2;

            var angle=angle,//anle=1度,1度为π/180
                cosAngle,
                cosAngle2,
                sinAngle,
                sinAngle2,
                rr,
                r0,
                r11,
                r12,
                EllipseX0,
                EllipseY0,
                EllipseX1,
                EllipseY1,
                EllipseX00,
                EllipseY00,
                EllipseX11,
                EllipseY11;


                angle=(Math.PI/180)*angle;//转为与π对应的值
                cosAngle=Math.cos(angle);
                cosAngle2=Math.pow(cosAngle,2);
                sinAngle=Math.sin(angle);
                sinAngle2=Math.pow(sinAngle,2);
                rr=g11*cosAngle2+2*g12*cosAngle*sinAngle+g22*sinAngle2;
                r0=Math.sqrt(rr);
                r11=(0.01*r1)/r0;
                r12=(0.01*r2)/r0;

                //EllipseX0,EllipseY0为第一个小圆上的坐标
                EllipseX0=x0+r11*cosAngle;
                EllipseY0=y0+r11*sinAngle;

                //EllipseX1,EllipseY1为第二个大圆上的坐标
                EllipseX1=x0+r12*cosAngle;
                EllipseY1=y0+r12*sinAngle;

                var result=[EllipseX0,EllipseY0,EllipseX1,EllipseY1,x0,y0];
                return result;

        },
        XYAxis:function(){
            //处理数据，得到最大，最小x,y值,方便在坐标轴系里面调用
            var resultXTotal=[],
                resultYTotal=[];
            for(var XYAxisAngle=0;XYAxisAngle<360;XYAxisAngle++){

                var arrDataModel=myEllipse.prototype.Setting.arrData;
                //将0-360度对应的点的坐标画出来
                var result=myEllipse.prototype.EllipseXY(arrDataModel,XYAxisAngle),
                    resultX=result[2],
                    resultY=result[3];

                    //所有X压入一个数组
                    resultXTotal.push(resultX);
                    //所有Y压入一个数组
                    resultYTotal.push(resultY);
            };

            //从小到大排列
            resultXTotal.sort(function(a,b){
                return a-b;
            });
            resultYTotal.sort(function(a,b){
                return a-b;
            });

            var xMax,
                xMin,
                yMax,
                yMin,
                sectionX,
                sectionY,
                sectionXStep,
                sectionYStep,
                sortResult=[];

            xMax=resultXTotal[resultXTotal.length-1];
            xMin=resultXTotal[0];

            yMax=resultYTotal[resultYTotal.length-1];
            yMin=resultYTotal[0];

            //为了保证一定在这个区间，我又往外扩了0.01
            xMin=(xMin-0.01).toFixed(2),
            xMax=(xMax+0.01).toFixed(2),
            yMin=(yMin-0.01).toFixed(2),
            yMax=(yMax+0.01).toFixed(2);

            //最大值和最小值之间的差值,sectionX,sectionY偏大行，偏小不行，可能溢出
            //section按8分，网页按10份分，八份点是9，不会超出，如果section是10就吵了，因为点数是11
            sectionX=xMax-xMin;
            sectionY=yMax-yMin;

            //均分八份
            sectionXStep=sectionX/8;
            sectionYStep=sectionY/8;

            myEllipse.prototype.Setting.xMin=xMin;
            myEllipse.prototype.Setting.xMax=xMax;
            myEllipse.prototype.Setting.yMin=yMin;
            myEllipse.prototype.Setting.yMax=yMax;
            myEllipse.prototype.Setting.sectionX=sectionX;
            myEllipse.prototype.Setting.sectionY=sectionY;
            myEllipse.prototype.Setting.sectionXStep=sectionXStep;
            myEllipse.prototype.Setting.sectionYStep=sectionYStep;


            sortResult[xMin,xMax,yMin,yMax,sectionX,sectionY,sectionXStep,sectionYStep];
            return sortResult;
        },
        XYTransition:function(arrData,angle){
            //处理一下将EllipseXY中的坐标转换为我们可以直接用的
            var result=myEllipse.prototype.EllipseXY(arrData,angle),
                EllipseX0=result[0],
                EllipseY0=result[1],
                EllipseX1=result[2],
                EllipseY1=result[3],
                x0=result[4],
                y0=result[5],
                EllipseX00,
                EllipseY00,
                EllipseX11,
                EllipseY11,
                x00,
                y00,
                xMin,
                yMin,
                mX,
                mY,
                kX,
                kY;

                xMin=myEllipse.prototype.Setting.xMin;
                yMin=myEllipse.prototype.Setting.yMin;
                mX=myEllipse.prototype.Setting.mX;
                mY=myEllipse.prototype.Setting.mY;
                kX=myEllipse.prototype.Setting.kX;
                kY=myEllipse.prototype.Setting.kY;
                //圆上所有的点进行转换
                //1对应mX,mY
                EllipseX00=(EllipseX0-xMin)*mX+kX;
                EllipseY00=myEllipse.prototype.Setting.contain_height-kY-(EllipseY0-yMin)*mY;

                Ellipsex11=(EllipseX1-xMin)*mX+kX;
                EllipseY11=myEllipse.prototype.Setting.contain_height-kY-(EllipseY1-yMin)*mY;

                x00=(x0-xMin)*mX+kX;
                y00=myEllipse.prototype.Setting.contain_height-kY-(y0-yMin)*mY;

                result=[EllipseX00,EllipseY00,Ellipsex11,EllipseY11,x00,y00];
                return result;
        },
    };
    $(function(){
        var aa=new myEllipse();
        aa.drawMain("main",arrData);
    })
    </script>

</body>
</html>